
    Array Operations
=========================

1 - Initialization: Creating an array with predefined or dynamic values.
2 - Traversal: Accessing each element of the array.
3 - Insertion: Adding an element at a specific position.
4 - Deletion: Removing an element from a specific position.
5 - Updating: Changing the value of an element at a specific position. also call "set".
6 - Searching: Finding an element in the array (e.g., linear search, binary search).
7 - Sorting: Arranging the elements in a particular order (e.g., ascending, descending).



    Time & Space Complexity
===============================

1. Initialization

  # Time Complexity: O(n)
    - Static initialization: O(n), where n is the number of elements in the array.
    - Dynamic initialization: O(n), where n is the number of elements in the array.
  # Space Complexity: O(n)
    - Static initialization: O(n), where n is the number of elements in the array.
    - Dynamic initialization: O(n), where n is the number of elements in the array.

2. Traversal

  # Time Complexity: O(n)
    - Both standard for-loop and enhanced for-loop traverse each element of the array once.
  # Space Complexity: O(1)
    - No additional space is used beyond the array itself.

3. Insertion (at a specific position)

  # Time Complexity: 
    - Worst case: O(n)
    - Inserting at the beginning or middle of the array requires shifting subsequent elements.
    - Best case (inserting at the end): O(1)
    - Inserting at the end does not require shifting elements.
  # Space Complexity: O(n)
    - In the worst case, when inserting at the beginning or middle, additional space is required for the new array.

4. Deletion (from a specific position)

  # Time Complexity: 
    - Worst case: O(n)
    - Deleting from the beginning or middle of the array requires shifting subsequent elements.
    - Best case (deleting from the end): O(1)
    - Deleting from the end does not require shifting elements.
  # Space Complexity: O(n)
    - In the worst case, when deleting from the beginning or middle, additional space is required for the new array.

5. Updating (at a specific position)

  # Time Complexity: O(1)
    - Updating an element directly at a specific index is a constant time operation.
  # Space Complexity: O(1)
    - No additional space is used beyond the array itself.

6. Searching

  Linear Search:
    # Time Complexity: O(n)
        - In the worst case, the element may be at the end of the array or not present.
    # Space Complexity: O(1)
        - No additional space is used beyond the array itself.
  Binary Search (only applicable if the array is sorted):
    # Time Complexity: O(log n)
        - Binary search divides the search interval in half at each step, resulting in logarithmic time complexity.
    # Space Complexity: O(1)
        - No additional space is used beyond the array itself.

7. Sorting

  # Time Complexity: O(n log n) for efficient sorting algorithms like Merge Sort or Quick Sort.
    - Java's `Arrays.sort()` typically uses a dual-pivot Quicksort for primitive types, which has an average time complexity of O(n log n).
  # Space Complexity: O(log n) to O(n)
    - Quicksort typically requires O(log n) auxiliary space for recursion stack, but in the worst case can be O(n).

Summary

  # Time Complexity: Represents how the time required for an operation grows with respect to the size of the input (array).
  # Space Complexity: Indicates the additional memory space required by an algorithm or operation.

